<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.png?v=5.1.4" color="#222">





  <meta name="keywords" content="柴毛毛, 大闲人柴毛毛" />










<meta name="description" content="本文是笔者的一点经验总结，主要介绍几种在Web开发中使用频率较高的设计模式。 本文篇幅较长，建议各位同学挑选感兴趣的设计模式阅读。 如需转载，请与我联系！">
<meta property="og:type" content="article">
<meta property="og:title" content="柴毛毛大话设计模式——开发常用设计模式全面解析">
<meta property="og:url" content="http://yoursite.com/2018/01/30/design-pattern/index.html">
<meta property="og:site_name" content="大闲人柴毛毛">
<meta property="og:description" content="本文是笔者的一点经验总结，主要介绍几种在Web开发中使用频率较高的设计模式。 本文篇幅较长，建议各位同学挑选感兴趣的设计模式阅读。 如需转载，请与我联系！">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6f177cab6441524d00a8f9">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6f18b0ab6441504a00a2e8">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6f1893ab6441524d00a926">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6f1924ab6441504a00a2fc">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6d8994ab6441765f000de3">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6d923cab6441765f000f48">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6dad1aab64417463001317">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6dcafcab6441765f00175c">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6dd487ab6441765f001905">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6ecbe9ab6441504a001e35">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6f2194ab6441524d00aaad">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a6f2aa5ab6441504a00a5d1">
<meta property="og:image" content="https://leanote.com/api/file/getImage?fileId=5a70511eab6441301b0022a6">
<meta property="og:image" content="http://img.blog.csdn.net/20150901085506176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2018-02-01T03:38:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="柴毛毛大话设计模式——开发常用设计模式全面解析">
<meta name="twitter:description" content="本文是笔者的一点经验总结，主要介绍几种在Web开发中使用频率较高的设计模式。 本文篇幅较长，建议各位同学挑选感兴趣的设计模式阅读。 如需转载，请与我联系！">
<meta name="twitter:image" content="https://leanote.com/api/file/getImage?fileId=5a6f177cab6441524d00a8f9">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/01/30/design-pattern/"/>





  <title>柴毛毛大话设计模式——开发常用设计模式全面解析 | 大闲人柴毛毛</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大闲人柴毛毛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">探寻计算机世界的本源</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-microservice">
          <a href="/categories/微服务/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-windows"></i> <br />
            
            微服务
          </a>
        </li>
      
        
        <li class="menu-item menu-item-design-pattern">
          <a href="/categories/设计模式/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bug"></i> <br />
            
            设计模式
          </a>
        </li>
      
        
        <li class="menu-item menu-item-networks">
          <a href="/categories/计算机网络/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-internet-explorer"></i> <br />
            
            计算机网络
          </a>
        </li>
      
        
        <li class="menu-item menu-item-jvm">
          <a href="/categories/JVM/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />
            
            JVM
          </a>
        </li>
      
        
        <li class="menu-item menu-item-java并发编程">
          <a href="/categories/Java并发编程/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />
            
            Java并发编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            时间轴
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于我
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/30/design-pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="柴毛毛">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大闲人柴毛毛">
    </span>

    
      <header class="post-header" style="border-bottom: 2px #ccc dashed;margin-bottom: 20px;">

        
        
          <h2 class="post-title" itemprop="name headline">柴毛毛大话设计模式——开发常用设计模式全面解析</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-30T20:38:47+08:00">
                2018-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2018/01/30/design-pattern/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2018/01/30/design-pattern/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,586 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  32 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li>本文是笔者的一点经验总结，主要介绍几种在Web开发中使用频率较高的设计模式。</li>
<li>本文篇幅较长，建议各位同学挑选感兴趣的设计模式阅读。</li>
<li><strong>如需转载，请与我联系！</strong></li>
</ul>
<a id="more"></a>
<h1 id="基础学习：UML四种关系"><a href="#基础学习：UML四种关系" class="headerlink" title="基础学习：UML四种关系"></a>基础学习：UML四种关系</h1><h2 id="耦合度大小关系"><a href="#耦合度大小关系" class="headerlink" title="耦合度大小关系"></a>耦合度大小关系</h2><blockquote>
<p>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p>
</blockquote>
<h2 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6f177cab6441524d00a8f9" alt="title"></p>
<ul>
<li>一个人(Person)可以买车(car)和房子(House)，那么就可以称：Person类<strong>依赖于</strong>Car类和House类</li>
<li>这里注意与下面的关联关系区分：Person类里并没有使用Car和House类型的属性，Car和House的实例是以参量的方式传入到buy()方法中。</li>
<li>依赖关系在Java语言中体现为<strong>局域变量</strong>、<strong>方法的形参</strong>，或者对静态方法的调用。</li>
</ul>
<h2 id="关联-Association）"><a href="#关联-Association）" class="headerlink" title="关联(Association）"></a>关联(Association）</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6f18b0ab6441504a00a2e8" alt="title"></p>
<ul>
<li>它使一个类知道另一个类的<strong>属性和方法</strong>。</li>
<li>关联可以是双向的，也可以是单向的。</li>
<li>在Java语言中，关联关系一般使用<strong>成员变量</strong>来实现。</li>
</ul>
<h2 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6f1893ab6441524d00a926" alt="title"></p>
<ul>
<li>聚合是<strong>关联关系的一种</strong>，是强的关联关系。</li>
<li>聚合是整体和个体之间的关系，但个体可以脱离整体而存在。</li>
<li>例如，汽车类与引擎类、轮胎类，以及其它的零件类之间的关系便整体和个体的关系。</li>
<li>与关联关系一样，聚合关系也是通过成员变量实现的。但是关联关系所涉及的两个类是处在同一层次上的，而在聚合关系中，两个类是处在不平等层次上的，一个代表整体，另一个代表部分。</li>
</ul>
<h2 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6f1924ab6441504a00a2fc" alt="title"></p>
<ul>
<li>组合是<strong>关联关系的一种</strong>，是<strong>比聚合关系强</strong>的关系，也以成员变量的形式出现。</li>
<li>在某一个时刻，部分对象只能和一个整体对象发生组合关系，由后者排他地负责生命周期。</li>
<li>部分和整体的生命周期一样。</li>
<li>整体可以将部分传递给另一个对象，这时候该部分的生命周期由新整体控制，然后旧整体可以死亡。</li>
</ul>
<hr>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="什么是策略模式"><a href="#什么是策略模式" class="headerlink" title="什么是策略模式"></a>什么是策略模式</h2><p>一个类中的一些行为，可能会随着系统的迭代而发生变化。为了使得该类满足<strong>开放-封闭原则（即：具备可扩展性 或 弹性）</strong>，我们需要将这些未来会发生动态变化的行为从该类中剥离出来，并通过预测未来业务发展的方式，为这些行为抽象出共有的特征，封装在抽象类或接口中，并通过它们的实现类提供具体的行为。原本类中需要持有该抽象类/接口的引用。在使用时，将某一个具体的实现类对象注入给该类所持有的接口/抽象类的引用。</p>
<h2 id="类图描述"><a href="#类图描述" class="headerlink" title="类图描述"></a>类图描述</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6d8994ab6441765f000de3" alt="title"></p>
<p>如果类A中有两个行为X和Y会随着业务的发展而变化，那么，我们需要将这两个行为从类A中剥离出来，并形成各自的继承体系(策略体系)。每个继承体系(策略体系)的顶层父类/接口中定义共有行为的抽象函数，每个子类/实现类中定义该策略体系具体的实现。</p>
<p>其中，每一个被抽象出来的继承体系被称为一个<strong>策略体系</strong>，每个具体的实现类被称为<strong>策略</strong>。</p>
<p>此时，策略体系已经构建完成，接下来需要改造类A。<br>在类A中增加所需策略体系的顶层父类/接口，并向外暴露一个共有的函数action给调用者使用。</p>
<p>在Spring项目中，策略类和类A之间的依赖关系可以通过<strong>依赖注入</strong>来完成。</p>
<p>到此为止，策略模式已经构建完成，下面我们来看优缺点分析。</p>
<h2 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h2><h3 id="1-满足开放封闭原则"><a href="#1-满足开放封闭原则" class="headerlink" title="1. 满足开放封闭原则"></a>1. 满足开放封闭原则</h3><p>如果类A需要更换一种策略的时候，只需修改Spring的XML配置文件即可，其余所有的代码均不需要修改。</p>
<p>比如，将类A的策略X_1更换成X_2的方法如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"类A"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将原本策略实现类X_1修改为策略实现类X_2即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"策略接口X"</span> <span class="attr">class</span>=<span class="string">"策略实现类X_2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此外，如果需要新增一种策略，只需要为策略接口X添加一个新的实现类即可，并覆盖其中的commonAction函数。然后按照上面的方式修改XML文件即可。</p>
<p>在这个过程中，在保持原有Java代码不发生变化的前提下，扩展性了新的功能，从而满足开放封闭原则。</p>
<h3 id="2-可方便地创建具有不同策略的对象"><a href="#2-可方便地创建具有不同策略的对象" class="headerlink" title="2. 可方便地创建具有不同策略的对象"></a>2. 可方便地创建具有不同策略的对象</h3><p>如果我们需要根据不同的策略创建多种类A的对象，那么使用策略模式就能很容易地实现这一点。</p>
<p>比如，我们要创建三个A类的对象，a、b、c。其中，a使用策略X_1和Y_1，b使用策略X_2和Y_2，c使用策略X_3和Y_3。<br>要创建这三个对象，我们只需在XML中作如下配置即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"a"</span> <span class="attr">class</span>=<span class="string">"类A"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"策略接口X"</span> <span class="attr">class</span>=<span class="string">"策略实现类X_1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"策略接口Y"</span> <span class="attr">class</span>=<span class="string">"策略实现类Y_1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">class</span>=<span class="string">"类A"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"策略接口X"</span> <span class="attr">class</span>=<span class="string">"策略实现类X_2"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"策略接口Y"</span> <span class="attr">class</span>=<span class="string">"策略实现类Y_2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"c"</span> <span class="attr">class</span>=<span class="string">"类A"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"策略接口X"</span> <span class="attr">class</span>=<span class="string">"策略实现类X_3"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"策略接口Y"</span> <span class="attr">class</span>=<span class="string">"策略实现类Y_3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><blockquote>
<p>问：如何实现部分继承？也就是类Son1只继承Father的一部分功能，Son2继承Father的另一部分功能。</p>
</blockquote>
<p>这是设计上的缺陷，当出现这种情况时，应当将父类再次拆分成2个子类，保证任何一个父类的行为和特征均是该继承体系中共有的！</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5a6d923cab6441765f000f48" alt="title"></p>
<blockquote>
<p>问：随着需求的变化，父类中需要增加共有行为时怎么办？这就破坏了“开放封闭原则”。</p>
</blockquote>
<p>这并未破坏“开放封闭原则”！在系统迭代更新的过程中，修改原有的代码是在所难免的，这并不违背“开放封闭原则”。<br>“开放封闭原则”要求我们：当系统在迭代过程中，第一次出现<strong>某一类型的需求</strong>时，是允许修改的；在此时，应该对系统进行修改，并进行合理地设计，以保证<strong>对该类型需求</strong>的再次修改具备可扩展性。当再一次出现该类型的需求时，就不应该修改原有代码，只允许通过扩展来满足需求。</p>
<hr>
<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="观察者模式是什么"><a href="#观察者模式是什么" class="headerlink" title="观察者模式是什么"></a>观察者模式是什么</h2><p>如果出现如下场景需求时，就需要使用观察者模式。</p>
<p>如果存在一系列类，他们都需要向指定类获取指定的数据，当获取到数据后需要触发相应的业务逻辑。这种场景就可以用观察者模式来实现。</p>
<p>在观察者模式中，存在两种角色，分别是：<strong>观察者</strong>和<strong>被观察者</strong>。被观察者即为数据提供者。他们呈多对一的关系。</p>
<h2 id="类图描述-1"><a href="#类图描述-1" class="headerlink" title="类图描述"></a>类图描述</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6dad1aab64417463001317" alt="title"></p>
<ul>
<li>被观察者是数据提供方，观察者是数据获取方</li>
<li>一个普通的类，如果要成为观察者，获取指定的数据，一共需要如下几步：<ul>
<li>首先，需要实现Observer接口，并实现update函数；</li>
<li>然后，在该函数中定义获取数据后的业务逻辑；</li>
<li>update(Observable, Object)一共有两个参数：<ul>
<li>Observable：被观察者对象（数据提供方）</li>
<li>Object：数据本身</li>
</ul>
</li>
<li>最后，通过调用 被观察者 的addObservable()或者通过Spring的XML配置文件完成观察者向被观察者的注入。此时，该观察者对象就会被添加进 被观察者 的List中。</li>
</ul>
</li>
<li>调用者才是真正的数据提供方。当调用者需要广播最新数据时，只需调用 被观察者 的notidyObservers()函数，该函数会遍历List集合，并依次调用每个Observer的update函数，从而完成数据的发送，并触发每个Observer收到数据后的业务逻辑。</li>
</ul>
<h2 id="两种注册观察者的方式"><a href="#两种注册观察者的方式" class="headerlink" title="两种注册观察者的方式"></a>两种注册观察者的方式</h2><p>将Observer注册进Observable中有如下两种方式：</p>
<h3 id="1-运行前，通过Spring-XML"><a href="#1-运行前，通过Spring-XML" class="headerlink" title="1. 运行前，通过Spring XML"></a>1. 运行前，通过Spring XML</h3><p>在系统运行前，如果观察者数量可以确定，并在运行过程中不会发生变化，那么就可以在XML中完成<code>List&lt;Observer&gt;</code>对象的注入，这种方式代码将会比较简洁。</p>
<ol>
<li><p>配置好所有 <strong>观察者 bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建observerA --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"observerA"</span> <span class="attr">class</span>=<span class="string">"ObservserA"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 创建observerB--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"observerB"</span> <span class="attr">class</span>=<span class="string">"ObservserB"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置好 被观察者 bean，并将所有<strong>观察者bean</strong>注入给<strong>被观察者bean</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建observable --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"observable"</span> <span class="attr">class</span>=<span class="string">"Observable"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"observerList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"observerA"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"observerB"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-运行中，通过addObserver-函数"><a href="#2-运行中，通过addObserver-函数" class="headerlink" title="2. 运行中，通过addObserver()函数"></a>2. 运行中，通过addObserver()函数</h3><p>在Spring初始化的时候，通过<code>addObserver</code>函数将<code>所有Observer对象</code>注入<code>Observable的</code>observerList`中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitConfiguration</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(event.getApplicationContext().getParent() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Observable observable = (Observable)event.getApplicationContext().getBean(<span class="string">"observable"</span>);</span><br><span class="line"></span><br><span class="line">            ObserverA observerA = (ObserverA)event.getApplicationContext().getBean(<span class="string">"observerA"</span>);</span><br><span class="line">            ObserverB observerB = (ObserverB)event.getApplicationContext().getBean(<span class="string">"observerB"</span>);</span><br><span class="line"></span><br><span class="line">            observable.setObserverList(Arrays.asList(observerA, observerB));</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议使用第一种方式初始化所有的观察者，此外，被观察者仍然需要提供<code>addObserver()</code>函数供系统在运行期间动态地添加、删除观察者对象。</p>
</blockquote>
<h2 id="JDK提供的观察者模式工具包"><a href="#JDK提供的观察者模式工具包" class="headerlink" title="JDK提供的观察者模式工具包"></a>JDK提供的观察者模式工具包</h2><p>JDK已经提供了观察者模式的工具包，包括<code>Observable类</code>和<code>Observer接口</code>。若要实现观察者模式，直接使用这两个工具包即可。</p>
<hr>
<h1 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h1><h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><ol>
<li><p>需要增强一个对象中某些函数的功能。</p>
</li>
<li><p>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</p>
</li>
<li><p>需要增加 由一些基本功能排列组合 而产生的大量功能，从而使继承体系大爆炸。</p>
</li>
</ol>
<h2 id="类图描述-2"><a href="#类图描述-2" class="headerlink" title="类图描述"></a>类图描述</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6dcafcab6441765f00175c" alt="title"><br>在装饰模式中的各个角色有：</p>
<ul>
<li><p>抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。</p>
</li>
<li><p>具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。</p>
</li>
<li><p>装饰（Decorator）角色：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。</p>
</li>
<li><p>具体装饰（Concrete Decorator）角色：负责给构件对象”贴上”附加的责任。</p>
</li>
</ul>
<p>Decorator中包含Component的成员变量，每个Concrete Decorator实现类均需要实现operation()函数，该函数大致过程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    返回类型 operation()&#123;</span><br><span class="line">        <span class="comment">// 执行上一层的operation()，并获取返回结果</span></span><br><span class="line">        返回结果 = component.operation();</span><br><span class="line">        <span class="comment">// 拿到返回结果后，再做额外的处理</span></span><br><span class="line">        处理返回结果</span><br><span class="line">        <span class="keyword">return</span> 返回结果;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用装饰类的过程如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备好所有装饰类</span></span><br><span class="line">DecoratorA decoratorA = <span class="keyword">new</span> DecoratorA();</span><br><span class="line">DecoratorB decoratorB = <span class="keyword">new</span> DecoratorB();</span><br><span class="line">DecoratorC decoratorC = <span class="keyword">new</span> DecoratorC();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备好 被装饰的类</span></span><br><span class="line">Component component = <span class="keyword">new</span> Component();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装装饰类</span></span><br><span class="line">decoratorC.setComponent(decoratorB);</span><br><span class="line">decoratorB.setComponent(decoratorA);</span><br><span class="line">decoratorA.setComponent(component);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">decoratorC.operation();</span><br></pre></td></tr></table></figure></p>
<p>执行过程如下：</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5a6dd487ab6441765f001905" alt="title"></p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li><p>Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。继承通过覆盖的方式重写需要扩展的函数，当然也可以通过<code>super.xxx()</code>获取原本的功能，然后在该功能基础上扩展新功能，但它只能增加某一项功能；如果要通过继承实现增加多种功能，那么需要多层继承多个类来实现；而Decorator模式可以在原有功能的基础上通过组合来增加新功能，这些新功能已经被封装成一个个独立的装饰类，在运行期间通过搭积木的方式选择装饰类拼凑即可。</p>
</li>
<li><p>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</p>
</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li><p>这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。</p>
</li>
<li><p>装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。</p>
</li>
<li><p>装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。</p>
</li>
</ol>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li>多用组合，少用继承。<br>利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。</li>
</ul>
<hr>
<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>Java中单例(Singleton)模式是一种广泛使用的设计模式。单例模式的主要作用是保证在Java程序中，某个类只有一个实例存在。一些管理器和控制器常被设计成单例模式。</p>
<p>单例模式有很多好处，它能够避免实例对象的重复创建，不仅可以减少每次创建对象的时间开销，还可以节约内存空间；能够避免由于操作多个实例导致的逻辑错误。如果一个对象有可能贯穿整个应用程序，而且起到了全局统一管理控制的作用，那么单例模式也许是一个值得考虑的选择。</p>
<p>单例模式有很多种写法，大部分写法都或多或少有一些不足。下面将分别对这几种写法进行介绍。</p>
<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>类的构造函数定义为private，保证其他类不能实例化此类；</li>
<li>然后提供了一个静态实例并返回给调用者；</li>
<li>饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在</li>
<li>优点：只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。</li>
<li>缺点：即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了。</li>
<li>适用场景：这种实现方式适合单例占用内存比较小，在初始化时就会被用到的情况。但是，如果单例占用的内存比较大，或单例只是在某个特定场景下才会用到，使用饿汉模式就不合适了，这时候就需要用到懒汉模式进行延迟加载。</li>
</ul>
<h2 id="懒汉模式-存在线程安全性问题"><a href="#懒汉模式-存在线程安全性问题" class="headerlink" title="懒汉模式(存在线程安全性问题)"></a>懒汉模式(存在线程安全性问题)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>懒汉模式中单例是在需要的时候才去创建的，如果单例已经创建，再次调用获取接口将不会重新创建新的对象，而是直接返回之前创建的对象。</li>
<li>如果某个单例使用的次数少，并且创建单例消耗的资源较多，那么就需要实现单例的按需创建，这个时候使用懒汉模式就是一个不错的选择。</li>
<li>但是这里的懒汉模式并没有考虑线程安全问题，在多个线程可能会并发调用它的getInstance()方法，导致创建多个实例，因此需要加锁解决线程同步问题，实现如下。</li>
</ul>
<h2 id="懒汉模式-线程安全，但效率低"><a href="#懒汉模式-线程安全，但效率低" class="headerlink" title="懒汉模式(线程安全，但效率低)"></a>懒汉模式(线程安全，但效率低)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)&#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加锁的懒汉模式看起来即解决了线程并发问题，又实现了延迟加载，然而它存在着性能问题，依然不够完美。synchronized修饰的同步方法比一般方法要慢很多，如果多次调用getInstance()，累积的性能损耗就比较大了。</p>
<h2 id="懒汉模式-线程安全，效率高"><a href="#懒汉模式-线程安全，效率高" class="headerlink" title="懒汉模式(线程安全，效率高)"></a>懒汉模式(线程安全，效率高)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式比上一种方式只多加了一行代码，那就是在synchronized之上又加了一层判断<code>if (instance == null)</code>。这样当单例创建完毕后，不用每次都进入同步代码块，从而能提升效率。当然，除了初始化单例对象的线程ThreadA外，可能还存在少数线程，在ThreadA创建完单例后，刚释放锁的时候进入同步代码块，但此时有第二道<code>if (instance == null)</code>判断，因此也就避免了创建多个对象。而且进入同步代码块的线程相对较少。</p>
<h2 id="静态内部类-懒汉-无锁"><a href="#静态内部类-懒汉-无锁" class="headerlink" title="静态内部类(懒汉+无锁)"></a>静态内部类(懒汉+无锁)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式同样利用了类加载机制来保证只创建一个instance实例。它与饿汉模式一样，也是利用了类加载机制，因此不存在多线程并发的问题。不一样的是，它是在内部类里面去创建对象实例。这样的话，只要应用中不使用内部类，JVM就不会去加载这个单例类，也就不会创建单例对象，从而实现懒汉式的延迟加载。也就是说这种方式可以同时保证延迟加载和线程安全。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;  </span><br><span class="line">    instance;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span></span>&#123;&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到的四种实现单例的方式都有共同的缺点：</p>
<ol>
<li><p>需要额外的工作来实现序列化，否则每次反序列化一个序列化的对象时都会创建一个新的实例。</p>
</li>
<li><p>可以使用反射强行调用私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。</p>
</li>
</ol>
<p>而枚举类很好的解决了这两个问题，使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，《Effective Java》作者推荐使用的方法。不过，在实际工作中，很少看见有人这么写。</p>
<hr>
<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在父类中定义算法的流程，而算法的某些无法确定的细节，通过抽象函数的形式，在子类中去实现。</p>
<p>也可以理解为，一套算法的某些步骤可能随着业务的发展而改变，那么我们可以将确定的步骤在父类中实现，而可变的步骤作为抽象函数让其在子类中实现。</p>
<h2 id="类图描述-3"><a href="#类图描述-3" class="headerlink" title="类图描述"></a>类图描述</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6ecbe9ab6441504a001e35" alt="title"></p>
<ul>
<li>在模板方法模式中，父类是一个抽象类，算法的每一步都被封装成一个函数，<code>templateMethod</code>函数将所有算法步骤串联起来。</li>
<li>对于不变的步骤，用<code>private</code>修饰，防止子类重写；</li>
<li>对于可变的步骤，用<code>abstract protected</code>修饰，必须要求子类重写；</li>
<li>子类重写完所有抽象函数后，调用<code>templateMethod</code>即可执行算法。</li>
</ul>
<hr>
<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><p>外观模式这种思想在项目中普遍存在，也极其容易理解，大家一定用过，只是没有上升到理论的层面。这里对这种思想进行介绍。</p>
<p>外观模式他屏蔽了系统功能实现的复杂性，向客户端提供一套极其简单的接口。客户端只需要知道接口提供什么功能，如何调用就行了，不需要管这些接口背后是如何实现的。从而使得客户端和系统之间的耦合度大大降低，客户端只需跟一套简单的Facade接口打交道即可。</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>作为一个基金交易平台，需要提供一套接口规范，供各个基金公司接入。然而，各个基金公司的接口各不相同，没有办法直接和平台接口对接。此时，各个基金公司需要自行实现一个适配器，适配器完成不同接口的转换工作，使得基金公司的接口和平台提供的接口对接上。</p>
<h2 id="三种适配器"><a href="#三种适配器" class="headerlink" title="三种适配器"></a>三种适配器</h2><p>适配器模式有三种实现方式，下面都以基金交易平台的例子来解释。</p>
<ul>
<li><p>基金公司的交易接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基金公司的交易接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FundCompanyTrade</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买入函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mairu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖出函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maichu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基金交易平台的交易接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基金交易平台的交易接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FundPlatformTrade</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 买入接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖出接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基金交易平台均通过如下代码调用各个基金公司的交易接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FundPlatformTrade fundPlatformTrade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买入基金</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fundPlatformTrade.buy();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卖出基金</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fundPlatformTrade.sell();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="方式1：类适配器"><a href="#方式1：类适配器" class="headerlink" title="方式1：类适配器"></a>方式1：类适配器</h3><blockquote>
<p>通过<strong>继承</strong>来实现接口的转换。</p>
</blockquote>
<ul>
<li>基金交易适配器：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">FundCompanyTrade</span> <span class="keyword">implements</span> <span class="title">FundPlatformTrade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mairu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        maichu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>适配器<code>Adapter</code>继承了<code>FundCompanyTrade</code>，因此拥有了<code>FundCompanyTrade</code>买入和卖出的能力；适配器<code>Adapter</code>又实现了<code>FundPlatformTrade</code>，因此需要实现其中的买入和卖出接口，这个过程便完成了基金公司交易接口向基金平台交易接口的转换。</p>
<p>使用时，只需将<code>Adapter</code>通过Spring注入给<code>Client类</code>的<code>fundPlatformTrade成员变量</code>即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 声明Adapter对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"adapter"</span> <span class="attr">class</span>=<span class="string">"Adapter"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将adapter注入给Client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"Client"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fundPlatformTrade"</span> <span class="attr">ref</span>=<span class="string">"adapter"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="方式2：对象适配器"><a href="#方式2：对象适配器" class="headerlink" title="方式2：对象适配器"></a>方式2：对象适配器</h3><blockquote>
<p>通过<strong>组合</strong>来实现接口的转换。</p>
</blockquote>
<ul>
<li>基金交易适配器：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">FundPlatformTrade</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FundCompanyTrade fundCompanyTrade;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fundCompanyTrade.mairu();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fundCompanyTrade.maichu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这种方式中，适配器<code>Adapter</code>并未继承<code>FundCompanyTrade</code>，而是将该对象作为成员变量注入进来，一样可以达到同样的效果。</p>
<h3 id="方式3：接口适配器"><a href="#方式3：接口适配器" class="headerlink" title="方式3：接口适配器"></a>方式3：接口适配器</h3><p>当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。</p>
<ul>
<li><p>目标接口：A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">e</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>适配器：Adapter<br>实现所有函数，将所有函数先置空。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"对象不支持这个功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"对象不支持这个功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"对象不支持这个功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"对象不支持这个功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">e</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"对象不支持这个功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"对象不支持这个功能"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现类：Ashili<br>继承适配器类，选择性地重写相应函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ashili</span> <span class="keyword">extends</span> <span class="title">Adapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现A方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实现d方法被调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>迭代器模式用于在无需了解容器内部细节的情况下，实现容器的迭代。</p>
</blockquote>
<p>容器用于存储数据，而容器的存储结构种类繁多。在不使用适配器模式的情况下，如果要迭代容器中的元素，就需要充分理解容器的存储结构。存储结构不同，导致了不同容器的迭代方式都不一样。这无疑增加了我们使用容器的成本。</p>
<p>而迭代器模式提出了一种迭代容器元素的新思路，迭代器规定了一组迭代容器的接口，作为容器使用者，只需会用这套迭代器即可。容器本身需要实现这套迭代器接口，并实现其中的迭代函数。也就是容器提供方在提供容器的同时，还需要提供迭代器的实现。因为容器本身是了解自己的存储结构的，由它来实现迭代函数非常合适。而我们作为容器的使用者，只需知道怎么用迭代器即可，无需了解容器内部的存储结构。</p>
<h2 id="类图描述-4"><a href="#类图描述-4" class="headerlink" title="类图描述"></a>类图描述</h2><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/iterator_pattern_uml_diagram.jpg" alt=""></p>
<p>在迭代器模式中，一共有两种角色：迭代器 和 容器</p>
<ul>
<li>迭代器 Iterator：封装了迭代容器的接口</li>
<li>容器 Container：存储元素的东西<ul>
<li>容器若要具备迭代的能力，就必须拥有<code>getIterator()</code>函数，该函数将会返回一个<code>迭代器对象</code></li>
<li>每个容器都有属于自己的迭代器内部类，该内部类实现了<code>Iterator</code>接口，并实现了其中用于迭代的两个函数<code>hasNext()</code>和<code>next()</code></li>
<li><code>boolean hasNext()</code>：用于判断当前容器是否还有尚未迭代完的元素</li>
<li><code>Object next()</code>：用于获取下一个元素</li>
</ul>
</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ul>
<li><p>迭代器接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>容器接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体的容器（必须实现Container接口）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameRepository</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> String names[] = &#123;<span class="string">"Robert"</span> , <span class="string">"John"</span> ,<span class="string">"Julie"</span> , <span class="string">"Lora"</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> NameIterator();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(index &lt; names.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())&#123;</span><br><span class="line">            <span class="keyword">return</span> names[index++];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体的容器实现了<code>Container</code>接口，并实现了其中的<code>getIterator()</code>函数，该函数用于返回该容器的迭代器对象。</p>
</li>
<li>容器内部需要实现自己的迭代器内部类，该内部类实现<code>Iterator</code>接口，并实现了其中的<code>hasNext()</code>和<code>next()</code>函数。</li>
</ul>
<p>当容器和容器的迭代器创建完毕后，接下来就轮到用户使用了，使用就非常简单了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPatternDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      NameRepository namesRepository = <span class="keyword">new</span> NameRepository();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</span><br><span class="line">         String name = (String)iter.next();</span><br><span class="line">         System.out.println(<span class="string">"Name : "</span> + name);</span><br><span class="line">      &#125;     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于使用者而言，只要知道<code>Iterator</code>接口，就能够迭代所有不同种类的容器了。</li>
</ul>
<hr>
<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>组合模式定义了<strong>树形结构</strong>的<strong>物理存储方式</strong>。</p>
</blockquote>
<p>现实世界中树形结构的东西，在代码实现中，都可以用组合模式来表示。</p>
<p>比如：多级菜单、公司的组织结构等等。</p>
<p>下面就以多级菜单为例，介绍组合模式。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们要实现一个多级菜单，并实现多级菜单的增删改查操作。菜单如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一级菜单A</span><br><span class="line">    二级菜单A_1</span><br><span class="line">        三级菜单A_1_1</span><br><span class="line">        三级菜单A_1_2</span><br><span class="line">        三级菜单A_1_3</span><br><span class="line">    二级菜单A_2</span><br><span class="line">一级菜单B</span><br><span class="line">    二级菜单B_1</span><br><span class="line">    二级菜单B_2</span><br><span class="line">    二级菜单B_3</span><br><span class="line">    二级菜单B_4</span><br><span class="line">        三级菜单B_4_1</span><br><span class="line">        三级菜单B_4_2</span><br><span class="line">        三级菜单B_4_3</span><br><span class="line">一级菜单C</span><br><span class="line">    二级菜单C_1</span><br><span class="line">    二级菜单C_2</span><br><span class="line">    二级菜单C_3</span><br></pre></td></tr></table></figure>
<p>菜单的特点如下：</p>
<ul>
<li>深度不限，可以有无限级菜单</li>
<li>每层菜单数量不限</li>
</ul>
<h2 id="类图描述-5"><a href="#类图描述-5" class="headerlink" title="类图描述"></a>类图描述</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a6f2194ab6441524d00aaad" alt="title"></p>
<ul>
<li><code>Item</code>表示树中的节点；</li>
<li><code>Item</code>中包含两个成员变量：<ul>
<li>parent`：指向当前节点的父节点</li>
<li>`childList：当前节点的子节点列表</li>
</ul>
</li>
<li>这种<code>Item</code>中又包含<code>Item</code>的关系就构成了组合模式。</li>
</ul>
<h2 id="注意：循环引用"><a href="#注意：循环引用" class="headerlink" title="注意：循环引用"></a>注意：循环引用</h2><p>在构建树的过程中，可能会出现循环引用，从而在遍历树的时候可能就会出现死循环。因此，我们需要在添加节点的时候避免循环引用的出现。</p>
<p>我们可以在<code>Item</code>中再添加一个<code>List</code>成员变量，用于记录根节点到当前节点的路径。该路径可以用每个节点的ID表示。一旦新加入的节点ID已经出现在当前路径中的时候，就说明出现了循环引用，此时应该给出提示。</p>
<p><img src="https://leanote.com/api/file/getImage?fileId=5a6f2aa5ab6441504a00a5d1" alt="title"></p>
<hr>
<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>如果一个函数中出现大量的、复杂的if-else判断，这时候就要考虑使用状态模式了。</p>
<p>因为大量的if-else中往往包含了大量的业务逻辑，很有可能会随着业务的发展而变化。如果将这些业务逻辑都写死在一个类中，那么当业务逻辑发生变化的时候就需要修改这个类，从而违反了<strong>开放封闭原则</strong>。而状态模式就能很好地解决这一问题。</p>
<p>状态模式将每一个判断分支都封装成一个独立的类，每一个判断分支成为一种“状态”，因此每一个独立的类就成为一个“状态类”。并且由一个全局状态管理者<code>Context</code>来维护当前的状态。</p>
<h2 id="类图描述-6"><a href="#类图描述-6" class="headerlink" title="类图描述"></a>类图描述</h2><p><img src="https://leanote.com/api/file/getImage?fileId=5a70511eab6441301b0022a6" alt="title"></p>
<ul>
<li>在状态模式中，每一个判断分支被成为一种状态，每一种状态，都会被封装成一个单独的状态类；</li>
<li>所有的状态类都有一个共同的接口——<code>State</code></li>
<li><code>State</code>接口中有一个<code>doAction函数</code>，每个状态类的状态处理逻辑均在该函数中完成；必须将<code>Context</code>对象作为<code>doAction函数</code>的参数传入。该函数的结构如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateA</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (满足条件) &#123;</span><br><span class="line">            <span class="comment">// 执行相应的业务逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 设置下一跳状态</span></span><br><span class="line">            context.setState(<span class="keyword">new</span> StateB());</span><br><span class="line">            <span class="comment">// 执行下一跳状态</span></span><br><span class="line">            context.doCurState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个状态类的<code>doAction函数</code>中都有且仅有一对if-else，if中填写满足条件时的业务逻辑，而else中填写不满足条件时的业务逻辑。</li>
<li>else中的代码都一样，有且仅有这两步：<ul>
<li>首先将context的state设为下一个状态对象；</li>
<li>然后调用context的<code>doCurState()</code>执行；</li>
</ul>
</li>
<li><code>Context类</code>其实就是原本包含那个巨大、复杂的if-else的类。该类中持有了State对象，表示当前要执行的状态对象。</li>
<li><p><code>Context类</code>必须要有一个<code>doCurState</code>函数，该函数的代码都一样：<code>state.doAction()</code></p>
</li>
<li><p>开启状态判断过程的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备好第一个状态</span></span><br><span class="line">StateA stateA = <span class="keyword">new</span> StateA();</span><br><span class="line"><span class="comment">// 设置第一个状态</span></span><br><span class="line">context.setState(stateA);</span><br><span class="line"><span class="comment">// 开始执行</span></span><br><span class="line">context.doCurState();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><p>状态模式将原本在一个类中的庞大的if-else拆分成一个个独立的状态类。原本这个包含庞大if-else的类成为<code>Context</code>，包含了当前的状态。<code>Context</code>只需要知道起始状态类即可，不需要知道其他状态类的存在。也就是<code>Context</code>只与第一个状态类发生耦合。而每一个状态类只和下一个状态类发生耦合，从而形成一条状态判断链。状态类之间的耦合通过Spring XML文件配置。这样，当判断逻辑发生变化的时候，只需要新增状态类，并通过修改XML的方式将新的状态类插入到判断逻辑中。从而满足了<strong>开放封闭原则</strong>。</p>
<hr>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h2><p><img src="http://img.blog.csdn.net/20150901085506176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="title"></p>
<p>代理模式是在不改变目标类和使用者的前提下，扩展该类的功能。</p>
<p>代理模式中存在『目标对象』和『代理对象』，它们必须实现相同的接口。用户直接使用代理对象，而代理对象会将用户的请求交给目标对象处理。代理对象可以对用户的请求增加额外的处理。</p>
<h2 id="Java动态代理的使用"><a href="#Java动态代理的使用" class="headerlink" title="Java动态代理的使用"></a>Java动态代理的使用</h2><ul>
<li>首先你得拥有一个目标对象，该对象必须要实现一个接口：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span>   </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span>   </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function">  </span>&#123;   </span><br><span class="line">    System.out.println( <span class="string">"call doSomething()"</span> );   </span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>其次，为目标对象增加额外的逻辑：</p>
<ol>
<li>自定义一个类，并实现InvocationHandler接口；</li>
<li>实现invoke函数，并将需要增加的逻辑写在该函数中；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>   </span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">  <span class="keyword">private</span> Object proxied;   </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">( Object proxied )</span>   </span></span><br><span class="line"><span class="function">  </span>&#123;   </span><br><span class="line">    <span class="keyword">this</span>.proxied = proxied;   </span><br><span class="line">  &#125;   </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">( Object proxy, Method method, Object[] args )</span> <span class="keyword">throws</span> Throwable   </span></span><br><span class="line"><span class="function">  </span>&#123;   </span><br><span class="line">    <span class="comment">//在转调具体目标对象之前，可以执行一些功能处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//转调具体目标对象的方法</span></span><br><span class="line">    <span class="keyword">return</span> method.invoke( proxied, args);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在转调具体目标对象之后，可以执行一些功能处理</span></span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>创建代理对象，调用者直接使用该对象即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RealSubject real = <span class="keyword">new</span> RealSubject();   </span><br><span class="line">Subject proxySubject = (Subject)Proxy.newProxyInstance(Subject.class.getClassLoader(),</span><br><span class="line">     <span class="keyword">new</span> Class[]&#123;Subject.class&#125;,</span><br><span class="line">     <span class="keyword">new</span> ProxyHandler(real));</span><br><span class="line"></span><br><span class="line">    proxySubject.doSomething();</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    
      <div>
            
              
            
      </div>

      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/qrcode.jpg" alt="柴毛毛 wechat" style="width: 200px; max-width: 100%;"/>
    <div>扫一扫订阅我的文章</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>请我一杯咖啡</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/WechatIMG45.jpeg" alt="柴毛毛 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/uploads/WechatIMG46.jpeg" alt="柴毛毛 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    柴毛毛
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2018/01/30/design-pattern/" title="柴毛毛大话设计模式——开发常用设计模式全面解析">http://yoursite.com/2018/01/30/design-pattern/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/28/juc13/" rel="next" title="Java并发编程的艺术(十三)——锁优化">
                <i class="fa fa-chevron-left"></i> Java并发编程的艺术(十三)——锁优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/01/31/SpringBoot+Dubbo+Docker+Jenkins/" rel="prev" title="手把手教你搭建一套可自动化构建的微服务框架">
                手把手教你搭建一套可自动化构建的微服务框架 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="SOHUCS"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="柴毛毛" />
            
              <p class="site-author-name" itemprop="name">柴毛毛</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">文章</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/chai-bo-zhou/" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-indent"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/u010425776" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-rocket"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/bz51" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:chaibozhou@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础学习：UML四种关系"><span class="nav-number">1.</span> <span class="nav-text">基础学习：UML四种关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#耦合度大小关系"><span class="nav-number">1.1.</span> <span class="nav-text">耦合度大小关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#依赖-Dependency"><span class="nav-number">1.2.</span> <span class="nav-text">依赖(Dependency)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关联-Association）"><span class="nav-number">1.3.</span> <span class="nav-text">关联(Association）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#聚合-Aggregation"><span class="nav-number">1.4.</span> <span class="nav-text">聚合(Aggregation)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#组合-Composition"><span class="nav-number">1.5.</span> <span class="nav-text">组合(Composition)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#策略模式"><span class="nav-number">2.</span> <span class="nav-text">策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是策略模式"><span class="nav-number">2.1.</span> <span class="nav-text">什么是策略模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图描述"><span class="nav-number">2.2.</span> <span class="nav-text">类图描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#策略模式的优点"><span class="nav-number">2.3.</span> <span class="nav-text">策略模式的优点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-满足开放封闭原则"><span class="nav-number">2.3.1.</span> <span class="nav-text">1. 满足开放封闭原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-可方便地创建具有不同策略的对象"><span class="nav-number">2.3.2.</span> <span class="nav-text">2. 可方便地创建具有不同策略的对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#答疑"><span class="nav-number">2.4.</span> <span class="nav-text">答疑</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#观察者模式"><span class="nav-number">3.</span> <span class="nav-text">观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#观察者模式是什么"><span class="nav-number">3.1.</span> <span class="nav-text">观察者模式是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图描述-1"><span class="nav-number">3.2.</span> <span class="nav-text">类图描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两种注册观察者的方式"><span class="nav-number">3.3.</span> <span class="nav-text">两种注册观察者的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-运行前，通过Spring-XML"><span class="nav-number">3.3.1.</span> <span class="nav-text">1. 运行前，通过Spring XML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-运行中，通过addObserver-函数"><span class="nav-number">3.3.2.</span> <span class="nav-text">2. 运行中，通过addObserver()函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK提供的观察者模式工具包"><span class="nav-number">3.4.</span> <span class="nav-text">JDK提供的观察者模式工具包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#装饰模式"><span class="nav-number">4.</span> <span class="nav-text">装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#何时使用"><span class="nav-number">4.1.</span> <span class="nav-text">何时使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图描述-2"><span class="nav-number">4.2.</span> <span class="nav-text">类图描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优点"><span class="nav-number">4.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缺点"><span class="nav-number">4.4.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计原则"><span class="nav-number">4.5.</span> <span class="nav-text">设计原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#单例模式"><span class="nav-number">5.</span> <span class="nav-text">单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#饿汉模式"><span class="nav-number">5.1.</span> <span class="nav-text">饿汉模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒汉模式-存在线程安全性问题"><span class="nav-number">5.2.</span> <span class="nav-text">懒汉模式(存在线程安全性问题)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒汉模式-线程安全，但效率低"><span class="nav-number">5.3.</span> <span class="nav-text">懒汉模式(线程安全，但效率低)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒汉模式-线程安全，效率高"><span class="nav-number">5.4.</span> <span class="nav-text">懒汉模式(线程安全，效率高)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态内部类-懒汉-无锁"><span class="nav-number">5.5.</span> <span class="nav-text">静态内部类(懒汉+无锁)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">5.6.</span> <span class="nav-text">枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模板方法模式"><span class="nav-number">6.</span> <span class="nav-text">模板方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义"><span class="nav-number">6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图描述-3"><span class="nav-number">6.2.</span> <span class="nav-text">类图描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#外观模式"><span class="nav-number">7.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#适配器模式"><span class="nav-number">8.</span> <span class="nav-text">适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义-1"><span class="nav-number">8.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种适配器"><span class="nav-number">8.2.</span> <span class="nav-text">三种适配器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方式1：类适配器"><span class="nav-number">8.2.1.</span> <span class="nav-text">方式1：类适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方式2：对象适配器"><span class="nav-number">8.2.2.</span> <span class="nav-text">方式2：对象适配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方式3：接口适配器"><span class="nav-number">8.2.3.</span> <span class="nav-text">方式3：接口适配器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器模式"><span class="nav-number">9.</span> <span class="nav-text">迭代器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义-2"><span class="nav-number">9.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图描述-4"><span class="nav-number">9.2.</span> <span class="nav-text">类图描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码实现"><span class="nav-number">9.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组合模式"><span class="nav-number">10.</span> <span class="nav-text">组合模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定义-3"><span class="nav-number">10.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子"><span class="nav-number">10.2.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图描述-5"><span class="nav-number">10.3.</span> <span class="nav-text">类图描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意：循环引用"><span class="nav-number">10.4.</span> <span class="nav-text">注意：循环引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#状态模式"><span class="nav-number">11.</span> <span class="nav-text">状态模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用场景"><span class="nav-number">11.1.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类图描述-6"><span class="nav-number">11.2.</span> <span class="nav-text">类图描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优点-1"><span class="nav-number">11.3.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#代理模式"><span class="nav-number">12.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代理模式-1"><span class="nav-number">12.1.</span> <span class="nav-text">代理模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java动态代理的使用"><span class="nav-number">12.2.</span> <span class="nav-text">Java动态代理的使用</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">柴毛毛</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">63.1k</span>
  
</div>


  <div class="powered-by">
    <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
      本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
  </div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cytry7KWU';
      var conf = 'c6adbca56d0de183d92f44f278375e75';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  









  





  

  

  

  
  

  

  

  

</body>
</html>
